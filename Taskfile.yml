version: "3"

tasks:
  get-deps:
    desc: Installs rust dependencies
    cmds:
      - cargo install watchexec-cli
      - cargo install git-serve
      - cargo install argocd-webhook-trigger

  git-serve:
    desc: Serves this git directory so that it is accessible to the minikube host so that ArgoCD can be useful in local development clusters where we don't have a remote repo. Uses python http.server with cgi passthrough to `git-http-backend` because ArgoCD requires git smart http. Git will be served on http://host.minikube.internal:5555/cgi-bin/git
    vars:
      GIT_PORT: 5555
      GIT_IP:
        sh: |-
          {{ if eq .OS "Windows_NT" }}echo 0.0.0.0{{else}}minikube ssh -- "awk '\$2 == \"host.minikube.internal\" {print \$1}' /etc/hosts"{{end}}
    cmds:
      - git-serve {{ .GIT_IP }} {{ .GIT_PORT }}

  bootstrap:
    desc: Applies all kubernetes resources needed to bootstrap a given cluster. Run like `task bootstrap -- local`
    vars:
      CONTEXT:
        sh: kubectl config current-context
    prompt: Bootstrapping is potentially destructive to the kubernetes cluster, ensure current context is correct. Bootstrapping argocd, root appset, and applying cluster config `clusters/{{ .CLI_ARGS }}.cluster.yaml` to kubectl context `{{ .CONTEXT }}`. Run with --dry to see kubectl commands. Are you sure?`
    cmds:
      - kubectl --context {{ .CONTEXT }} apply --kustomize apps/reloader
      - kubectl --context {{ .CONTEXT }} wait -n reloader --for create pods -l app=reloader-reloader --timeout=90s
      - kubectl --context {{ .CONTEXT }} wait -n reloader --for condition=Ready pods -l app=reloader-reloader --timeout=90s
      - kubectl --context {{ .CONTEXT }} apply --kustomize apps/argo-cd/base
      - kubectl --context {{ .CONTEXT }} wait --all-namespaces --for create --timeout=60s crd/applicationsets.argoproj.io
      - kubectl --context {{ .CONTEXT }} wait --all-namespaces --for condition=established --timeout=60s crd/applicationsets.argoproj.io
      - kubectl --context {{ .CONTEXT }} wait --all-namespaces --for create --timeout=60s crd/appdecisions.app-decisions.example.com
      - kubectl --context {{ .CONTEXT }} wait --all-namespaces --for condition=established --timeout=60s crd/appdecisions.app-decisions.example.com
      - kubectl --context {{ .CONTEXT }} apply -f clusters/{{ .CLI_ARGS }}.cluster.yaml
      - kubectl --context {{ .CONTEXT }} apply -f app-of-apps/root.as.yaml
      - task: patch-secrets
        vars:
          CONTEXT: "{{ .CONTEXT }}"
          SECRET_NS: keycloak
          SECRET_NAME: postgres-admin
          SECRET_KEY: password

  tunnel:
    desc: Port forwards *.localho.st:8443 and *.localho.st:8080 to the istio ingress service
    vars:
      INGRESS_HTTPS_PORT: 8443
      INGRESS_HTTP_PORT: 8080
    cmds:
      - kubectl wait -n istio-ingress --for=create svc/istio-gateway --timeout=120s
      - kubectl port-forward -n istio-ingress --address localhost svc/istio-gateway {{ .INGRESS_HTTPS_PORT }}:8443 {{ .INGRESS_HTTP_PORT }}:8080

  patch-secrets:
    desc: Update secrets with random values
    vars:
      CONTEXT: na
      SECRET_NS: na
      SECRET_NAME: na
      SECRET_KEY: na
      SECRET_VALUE:
        sh: minikube ssh 'cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 28 | head -n 1'
    cmds:
      # - kubectl wait -n {{ .SECRET_NS }} --for=create secret/{{ .SECRET_NAME }} --timeout=10m
      - |-
        kubectl patch -n {{ .SECRET_NS }} secret {{ .SECRET_NAME }} --patch='{"stringData": { {{ .SECRET_KEY | toJson }}: {{ .SECRET_VALUE | toJson }} }}'

  refresh:
    desc: Sends webhook to local argocd (https://argocd.localho.st:8443) telling it to refresh the apps that changed in the last commit. Watches for new commits
    vars:
      GIT_PORT: 5555
      INGRESS_HTTPS_PORT: 8443
      REPO: "http://host.minikube.internal:{{ .GIT_PORT }}/.git"
      ARGOCD_SERVER: "https://argocd.localho.st:{{ .INGRESS_HTTPS_PORT }}"
    cmds:
      - watchexec -i .git/refs/heads/* -- argocd-webhook-trigger {{ .REPO }} {{ .ARGOCD_SERVER }} -k
